>> Database Management System (DBMS)

>> Relational Databases and Non-Relational Databases = NoSQL

>> SQL = Structured Query Language 

>> NoSQL systems don't understand SQL,,, they have their own query language

>> RDBMS examples -->  . MySQL
		       . SQL Server
		       . Oracle ... 

>> database <-- tables

>> every row in table = record

_________________________________________________________________________________________________________________________________________


>> To select database for which we want to write a query
   - USE less_db;

>> To see which database is currently selected
   - SELECT database();

>> To select all data from the `customers` table
   - SELECT * FROM customers;

>> - SELECT * FROM customers WHERE customer_id = 1;

>> To sort the data specifying the columns that we wanna sort the result on (in ascending way)
   - SELECT * FROM customers ORDER BY firstName; 

     -- if specified column type is varchar -> sorting is done in alphabetical way

>> To sort in descending way
   - SELECT * FROM customers ORDER BY firstName DESC;	

>> Arithmetic expressions can be used in SELECT clause (+ - * / %)     % - remainder
   - SELECT 
		first_name,
		last_name,
		Quantity,
		(Quantity + 10) * 100
     FROM customers;

     -- in this case the name of the column is (Quantity + 10) * 100

>> To change the column name use AS keyword (the 4th column will be called discount_factor)
   - SELECT
		first_name, 
		last_name,
		Quantity,
		(Quantity + 10) * 100 AS discount_factor
     FROM customers;

>> if you have a space in the column name, you need to surround them with quotes ('' or "")
   - SELECT
		first_name, 
		last_name,
		Quantity,
		(Quantity + 10) * 100 AS "discount factor"
     FROM customers;

>> To get the unique list of the column values use SELECT DISTINCT clause
   - SELECT DISTINCT states FROM customers;

>> WHERE clause and comparison operators
	>
	>=
	<
	<=
	=
	!= or <> (not equal)

>> when dealing with strings (textual data) and dates, use quotes ""
   - SELECT * FROM customers WHERE customerName = "Avigilon";
   - SELECT * FROM customers WHERE birthdate > '1990-01-01';




_________________________________________________________________________________________________________________________________________


>> The AND, OR, NOT logical operators
   
        -- AND -> all conditions should be True
	-- OR  -> at least one of the conditions is True

   - SELECT *
     FROM drivers
     WHERE hdate > '2019-01-01' AND rate > 88;

_________________________________________________________________________________________________________________________________________


>> The priority of AND, OR operators

        -- AND is always evaluated first (as * /)
        -- use parentheses () to change the default order

   - SELECT *
     FROM customers
     WHERE birthDate > '2019-01-01' OR points > 1000 AND state = 'VA';
        
	-- at first it checks conditions before and after AND, and only then goes to OR operator
        
	-- we can also write the above code in this way
   - SELECT * 
     FROM customers
     WHERE (birth_date > '2019-01-01') OR
           (points > 1000 AND state = 'VA');

        -- These are customers that are born either (after 2019-01-01) OR (have more than a 1000 points AND live in VA)


__________________________________________________________________________________________________________________________________________


>> To negate (отрицать) the written condition use NOT operator
   - SELECT *
     FROM customers
     WHERE NOT (birth_date > '2019-01-01' OR points > 1000);

        -- These will be customers that are born before 2019-01-01 and have less than 1000 points
        -- To simplify and understand this
              -- apply NOT operator to the first condition (negate it) 
			-- NOT (birth_date > '2019-01-01') <=> (birth_date <= '2019-01-01')
              -- apply NOT operator to OR to negate the OR
			-- NOT OR <=> AND
	      -- apply NOT operator to the second condition
			-- NOT (points > 1000) <=> (points <= 1000)
	-- So we can write the above code in the following way as they are equivalent
   - SELECT *
     FROM customers 
     WHERE birth_date <= '2019-01-01' AND points <= 1000;


__________________________________________________________________________________________________________________________________________


>> we can also use Arithmetic Expressions in the WHERE clause, ex:
   - SELECT *
     FROM order_items
     WHERE order_id = 6 AND unit_price * Quantity > 30;


__________________________________________________________________________________________________________________________________________


>> IN operator
>> use the IN operator when you want to compare an attribute to a list of values
   - SELECT *
     FROM customers 
     WHERE state = 'VA' OR state = 'FL' OR state = 'GA';

         -- but there is a shorter and cleaner way to get the same result
   - SELECT * 
     FROM customers
     WHERE state IN ('VA', 'FL', 'GA');

         -- to get the customers outside of the mentioned states
   - SELECT *
     FROM customers
     WHERE state NOT IN ('VA', 'FL', 'GA');


_________________________________________________________________________________________________________________________________________


>> BETWEEN operator
>> whenever you are comparing an attribute with a range of values, you can use the BETWEEN operator
   - SELECT *
     FROM customers
     WHERE id >= 35 AND id <= 40;
 
        -- the equivalent of this code will be (we can rewrite this expression)
   - SELECT * 
     FROM customers 
     WHERE id BETWEEN 35 AND 40;


        -- ex: return customers born between 1/1/1990 and 1/1/2000
        -- we can use the BETWEEN operator for date values as well 
   - SELECT *
     FROM customers
     WHERE birth_date BETWEEN '1990-01-01' AND '2020-01-01';



_________________________________________________________________________________________________________________________________________


>> LIKE operator
>> retrieve rows that match a specific string pattern
>> % to represent any number of characters
   _ to represent a single character

        -- to get the customers whose last_name starts with 'b'
   - SELECT *
     FROM customers 
     WHERE last_name LIKE 'b%'

        -- use the % sign to indicate any number of characters with the mentioned pattern 

        -- to get the customers who have a 'b' somewhere in their last_name (in the beginning, in the middle or at the end)
   - SELECT *
     FROM customers
     WHERE last_name LIKE '%b%'

        -- to get the customers whose last_name ends with 'y'
   - SELECT *
     FROM customers
     WHERE last_name LIKE '%y'

        -- _ use underscore to mention concrete number of letters
		-- get customers whose last_name starts with 'b', after 'b' have exactly 4 characters and ends with 'y'
		
   - SELECT *
     FROM customers
	 WHERE last_name LIKE 'b____y'
	 
	 
		-- get the customers whose addresses contain TRAIL or AVENUE
   - SELECT *
     FROM customers
	 WHERE address LIKE '%trail%' OR
	       address LIKE '%avenue%'
		   
		  
		-- get the customers whose phone numbers end with 9
   - SELECT *
     FROM customers
	 WHERE phone_number LIKE '%9'
	 
	 
	    -- get the customers whose phone numbers don't end with 9
   - SELECT * 
     FROM customers
	 WHERE phone_number NOT LIKE '%9'
	 
	 
	 
_____________________________________________________________________________________________________________________________________________



>> REGEXP operator (Regular Expression)

   - SELECT *
     FROM customers
	 WHERE last_name LIKE '%field%' 
								('field' can be in the beginning, in the middle or at the end)
	 
	    -- we can rewrite the above code 
   - SELECT *
     FROM customers
	 WHERE last_name REGEXP 'field'
	 
	 
	    -- ^ (this sign is called carrot) to indicate the beginning of a string
		-- our last_name must start with 'field'
   - SELECT *
     FROM customers 
	 WHERE last_name REGEXP '^field'
	 
	 
	    -- $ to indicate the end of a string
		-- the last_name must end with 'field'
   - SELECT *
     FROM customers
     WHERE last_name REGEXP 'field$'	 
	 
	 
	    -- get customers who have the word 'field' or 'mac' or 'rose' in their last_name
   - SELECT *
     FROM customers 
	 WHERE last_name REGEXP 'field|mac|rose'
	 
	 
	    -- get customers whose last_name must either start with 'field' or have the word 'mac' in it or the word 'rose' in it
   - SELECT *
     FROM customers 
	 WHERE last_name REGEXP '^field|mac|rose'
	 
	 
	    -- get customers who have an 'e' in their last_name
   - SELECT *
     FROM customers
	 WHERE last_name REGEXP 'e'
	 
	 
	    -- before the letter 'e' must either have 'g', 'i', 'm'
		-- matches any customers who have 'ge' or 'ie' or 'me' in their last_name 
   - SELECT *
     FROM customers
	 WHERE last_name REGEXP '[gim]e'
	 
	 
	 
	    -- any customers who have 'e' followed by 'f' or 'm' or 'q'
   - SELECT * 
     FROM customers 
	 WHERE last_name REGEXP 'e[fmq]'
	 
	 
	 
	    -- before 'e' we can have any characters from 'a' to 'h' (a,b,c,d,e,f,g)
   - SELECT *
     FROM customers
	 WHERE last_name REGEXP '[a-h]e'
	 
	 
	    -- ^ the beginning
		-- $ the end
		-- | logical OR    (| pipe or vertical bar)
		-- [abcd]
		-- [a-f]
		
		
		-- get the customers whose first names are ELKA or AMBUR 
   - SELECT *
     FROM customers
	 WHERE first_name REGEXP 'elka|ambur'
	 
	 
	    -- get the customers whose last names end with EY or ON
   - SELECT *
     FROM customers
	 WHERE last_name REGEXP 'EY$|ON$'
	 
	 
	    -- get the customers whose last names contain B followed by R or U
   - SELECT *
     FROM customers 
	 WHERE last_name REGEXP 'b[ru]'
	 
	 OR
	 
   - SELECT * 
     FROM customers
	 WHERE last_name REGEXP 'br|bu'
	 
	 
	 
_________________________________________________________________________________________________________________________________________

	 
>> The IS NULL operator
>> NULL <=> the absence of a value

        -- get all the customers who don't have a phone
   - SELECT *
     FROM customers
	 WHERE phone IS NULL;
	 
	    -- to get the customers who do have a phone
   - SELECT *
     FROM customers
	 WHERE phone IS NOT NULL;
	 
	 
	 
__________________________________________________________________________________________________________________________________________


>> ORDER BY clause
>> ID column (primary key) is the default sort column.

        -- we can also sort data by multiple columns
        -- Ex: first we wanna sort our customers based on their 'state', and then within each state we wanna sort them by their first_name
   - SELECT *
     FROM customers
	 ORDER BY state, first_name;
	    -- for example, if we have 2 rows with "FL" state, these 2 rows will be sorted based on 'first_name' column
		
		
		-- we can sort these customers by their state in descending order and then sort them by their first_name in descending order
   - SELECT *
     FROM customers
	 ORDER BY state DESC, first_name DESC;
	 
	 
	    -- write a query to have only the items for the order with ID 2 and to sort these items based on the total price for each item in descending order
		   (columns are 'order_id', 'product_id', 'quantity', 'unit_price')
   - SELECT *, unit_price * quantity AS total_price
     FROM order_items
     WHERE order_id = 2
	 ORDER BY total_price DESC;
	 
	 
__________________________________________________________________________________________________________________________________________



>> The LIMIT clause


        -- if we wanna get the first 3 customers
   - SELECT * 
     FROM customers
	 LIMIT 3;
	 
	 
	    -- we wanna skip the first 6 records and then pick 3 records
		-- 6 is the offset
   - SELECT *
     FROM customers
	 LIMIT 6, 3;
	 
	    
		-- Get the top 3 loyal customers (have more points than everyone else)
   - SELECT *
     FROM customers
	 ORDER BY points DESC
	 LIMIT 3;
	 
	 
>> The order of these clauses matters

    - SELECT
	- FROM
	- WHERE
	- ORDER BY
	- LIMIT
	
	
__________________________________________________________________________________________________________________________________________



>> INNER JOINS
>> INNER JOIN <=> JOIN
>> select columns from multiple tables

   - SELECT *
     FROM orders
	 INNER JOIN customers
		   ON orders.customer_id = customers.customer_id

        -- The first columns are the columns in the orders table, then the columns in the customers table
		-- Let's select some columns in the above query
   - SELECT order_id, first_name, last_name
     FROM orders
	 JOIN customers
	      ON orders.customer_id = customers.customer_id
		  
		  
        -- If we want to select customer_id column as well and we write the following query, we'll get an error
	- SELECT order_id, customer_id, first_name, last_name
	  FROM orders
	  JOIN customers
	       ON orders.customer_id = customers.customer_id
	
	!!!!! ERROR - because we have 'customer_id' column in both orders and customers tables, so you should specify which one
	- SELECT order_id, orders.customer_id, first_name, last_name
	  FROM orders
	  JOIN customers
	       ON orders.customer_id = customers.customer_id;
		   
>> The sequence of clauses
    - SELECT
	- FROM
	- JOIN _ ON _ (INNER JOIN _ ON _)
    - WHERE
	- LIMIT
	
>> In the above query we have repeated 'orders' and 'customers' words in multiple places
   we can get rid of this repetition by using an alias
   right after each table we can give it an alias
   
   - SELECT order_id, o.customer_id, first_name, last_name
     FROM orders o
	 JOIN customers c
          ON o.customer_id = c.customer_id;

       
        -- another example
   - SELECT orders.id, customerid, Customers.id, companyName
	 FROM orders
     INNER JOIN Customers
                ON orders.customerid = Customers.id
     WHERE orders.id >= 15155
     LIMIT 10;


__________________________________________________________________________________________________________________________________________	 
   
	 
>> JOINING ACCROSS DATABASES

   - SELECT *
     FROM orders o
	 JOIN cityLine.consignees c
		  ON o.consignee_id = c.id
		  
		  
__________________________________________________________________________________________________________________________________________



>> SELF JOINS
>> In SQL we can also join a table with itself

   Columns - employee_id, first_name, last_name, job_title, salary, reports_to (= this is the id of the manager for this employee) 
   This manager is actually an employee of the same organisation.
   
   - SELECT *
     FROM employees e
	 JOIN employees m 
		ON e.reports_to = m.employee_id
		
		-- we see all the columns of the employees table and then after that we have information about the manager
		
		-- Let's simplify the query and select only the name of the employee and their manager
		
   - SELECT e.employee_id,
			e.first_name,
			m.first_name AS manager
	 FROM employees e 
	 JOIN employees m 
		ON e.reports_to = m.employee_id
		
		-- we'll get columns `employee_id`, `first_name`, `manager`
		
		
__________________________________________________________________________________________________________________________________________

	 
		